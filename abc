!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!pip install -q kaggle

!kaggle datasets download -d orvile/wesad-wearable-stress-affect-detection-dataset

import zipfile
import os
zip_path = '/content/wesad-wearable-stress-affect-detection-dataset.zip'
extract_path = '/content/wesad_extracted' 
os.makedirs(extract_path, exist_ok=True)
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)
print(f"Dataset extracted to: {extract_path}")
print("\nContents of extracted directory:")
for item in os.listdir(extract_path):
    print(f"- {item}")

import pickle
import os
data_path = '/content/wesad_extracted/WESAD'
subject_id = 'S2'  
subject_file = os.path.join(data_path, subject_id, f'{subject_id}.pkl')
if os.path.exists(subject_file):
    with open(subject_file, 'rb') as f:
        subject_data = pickle.load(f, encoding='latin1') 
    print(f"Content of {subject_file}:")
    if isinstance(subject_data, dict):
        print("Keys in the data:", subject_data.keys())  
    else:
        print(subject_data) 
else:
    print(f"File not found: {subject_file}")

import pandas as pd
if isinstance(subject_data, dict) and 'signal' in subject_data and 'wrist' in subject_data['signal']:
    wrist_data = subject_data['signal']['wrist']
    if 'ACC' in wrist_data and wrist_data['ACC'].shape[1] == 3:
        acc_df = pd.DataFrame(wrist_data['ACC'], columns=['ACC_x', 'ACC_y', 'ACC_z'])
        print("\nACC sensor data as a DataFrame:")
        display(acc_df.head())
    elif 'ACC' in wrist_data:
         print(f"Warning: Unexpected shape for ACC data: {wrist_data['ACC'].shape}. Cannot create DataFrame with expected columns.")       
         acc_df = pd.DataFrame(wrist_data['ACC'])
         print("\nACC sensor data as a DataFrame (generic columns):")
         display(acc_df.head())    
    if 'BVP' in wrist_data:      
        bvp_data = wrist_data['BVP'].flatten() if wrist_data['BVP'].ndim == 2 else wrist_data['BVP']
        bvp_df = pd.DataFrame(bvp_data, columns=['BVP'])
        print("\nBVP sensor data as a DataFrame:")
        display(bvp_df.head()) 
    if 'EDA' in wrist_data:        
        eda_data = wrist_data['EDA'].flatten() if wrist_data['EDA'].ndim == 2 else wrist_data['EDA']
        eda_df = pd.DataFrame(eda_data, columns=['EDA'])
        print("\nEDA sensor data as a DataFrame:")
        display(eda_df.head())
    if 'TEMP' in wrist_data:  
        temp_data = wrist_data['TEMP'].flatten() if wrist_data['TEMP'].ndim == 2 else wrist_data['TEMP']
        temp_df = pd.DataFrame(temp_data, columns=['TEMP'])
        print("\nTEMP sensor data as a DataFrame:")
        display(temp_df.head())
else:
    print("Could not find 'wrist' data in the loaded object.")

import pandas as pd
import numpy as np
if isinstance(subject_data, dict) and 'signal' in subject_data and 'chest' in subject_data['signal']:
    chest_data = subject_data['signal']['chest']
    print("Structure of chest_data:")
    for key, value in chest_data.items():
        print(f"- {key}: shape {value.shape}, dtype {value.dtype}")
    chest_dfs = {}
    for key, value in chest_data.items():
        try:
            if value.ndim == 2:
                if value.shape[1] > 1:
                    columns = [f'{key}_{i}' for i in range(value.shape[1])]
                    chest_dfs[key] = pd.DataFrame(value, columns=columns)
                else:
                     chest_dfs[key] = pd.DataFrame(value.flatten(), columns=[key])
            elif value.ndim == 1:
                chest_dfs[key] = pd.DataFrame(value, columns=[key])
            else:
                print(f"Warning: Unexpected dimensions for {key} data: {value.ndim}")
                continue 
            print(f"\n{key} sensor data as a DataFrame:")
            display(chest_dfs[key].head())
        except Exception as e:
            print(f"Error creating DataFrame for {key}: {e}")
else:
    print("Could not find 'chest' data in the loaded object.")

def explore_structure(data, indent=0):
    """Recursively explores the structure of nested data."""
    if isinstance(data, dict):
        for key, value in data.items():
            print('  ' * indent + f"Key: {key}, Type: {type(value)}")
            explore_structure(value, indent + 1)
    elif isinstance(data, list):
        print('  ' * indent + f"Type: list, Length: {len(data)}")
        if len(data) > 0:           
            print('  ' * (indent + 1) + "Exploring first element:")
            explore_structure(data[0], indent + 2)
    elif isinstance(data, np.ndarray):
        print('  ' * indent + f"Type: np.ndarray, Shape: {data.shape}, Dtype: {data.dtype}")
    else:
        print('  ' * indent + f"Type: {type(data)}")
print("Exploring the structure of subject_data:")
explore_structure(subject_data)


import numpy as np
from scipy.signal import resample
target_freq = 64 # Hz
original_freqs = {
    'chest_ACC': 700,
    'chest_ECG': 700,
    'chest_EMG': 700,
    'chest_EDA': 700,
    'chest_Temp': 700,
    'chest_Resp': 700,
    'wrist_ACC': 32,
    'wrist_BVP': 64,
    'wrist_EDA': 4,
    'wrist_TEMP': 4
}
resampled_dfs = {}
wrist_dfs = {
    'wrist_ACC': acc_df,
    'wrist_BVP': bvp_df,
    'wrist_EDA': eda_df,
    'wrist_TEMP': temp_df
}
print("Resampling wrist sensor data to 64 Hz:")
for sensor_name, df in wrist_dfs.items():
    original_freq = original_freqs[sensor_name]
    if original_freq != target_freq:       
        num_original_samples = len(df)
        duration = num_original_samples / original_freq
        num_target_samples = int(duration * target_freq)   
        resampled_data = {}
        for col in df.columns:
            resampled_data[col] = resample(df[col], num_target_samples)
        resampled_dfs[sensor_name] = pd.DataFrame(resampled_data, columns=df.columns)
        print(f"- Resampled {sensor_name} from {original_freq} Hz to {target_freq} Hz. Original shape: {df.shape}, Resampled shape: {resampled_dfs[sensor_name].shape}")
    else:
        resampled_dfs[sensor_name] = df 
        print(f"- {sensor_name} is already at {target_freq} Hz. Shape: {df.shape}")
chest_sensor_map = {
    'ACC': 'chest_ACC',
    'ECG': 'chest_ECG',
    'EMG': 'chest_EMG',
    'EDA': 'chest_EDA',
    'Temp': 'chest_Temp', 
    'Resp': 'chest_Resp'
}
print("\nResampling chest sensor data to 64 Hz:")
if 'chest_dfs' in locals(): 
    for sensor_key, df in chest_dfs.items():
        if sensor_key in chest_sensor_map:
            sensor_name = chest_sensor_map[sensor_key]
            original_freq = original_freqs[sensor_name]
            if original_freq != target_freq:                 
                num_original_samples = len(df)
                duration = num_original_samples / original_freq
                num_target_samples = int(duration * target_freq)             
                resampled_data = {}
                for col in df.columns:
                    resampled_data[col] = resample(df[col], num_target_samples)
                resampled_dfs[sensor_name] = pd.DataFrame(resampled_data, columns=df.columns)
                print(f"- Resampled {sensor_name} from {original_freq} Hz to {target_freq} Hz. Original shape: {df.shape}, Resampled shape: {resampled_dfs[sensor_name].shape}")
            else:
                resampled_dfs[sensor_name] = df 
                print(f"- {sensor_name} is already at {target_freq} Hz. Shape: {df.shape}")
        else:
             print(f"Warning: Skipping unknown chest sensor key: {sensor_key}")
else:
    print("Chest DataFrames (chest_dfs) not found. Please ensure the cell to create them has been run.")
print("\nExample of resampled wrist ACC data:")
if 'wrist_ACC' in resampled_dfs:
    display(resampled_dfs['wrist_ACC'].head())
print("\nExample of resampled chest ECG data:")
if 'chest_ECG' in resampled_dfs:
    display(resampled_dfs['chest_ECG'].head())

from scipy.signal import butter, filtfilt
def apply_filter(data, lowcut, highcut, fs, order, filter_type):
    nyquist = 0.5 * fs
    low = lowcut / nyquist if lowcut is not None else None
    high = highcut / nyquist if highcut is not None else None   
    if low is not None and (low < 0 or low >= 1):
         raise ValueError(f"Normalized lowcut frequency ({low}) is out of valid range [0, 1). Original lowcut: {lowcut} Hz, Nyquist: {nyquist} Hz")
    if high is not None and (high <= 0 or high >= 1):
         raise ValueError(f"Normalized highcut frequency ({high}) is out of valid range (0, 1). Original highcut: {highcut} Hz, Nyquist: {nyquist} Hz")
    if low is not None and high is not None and low >= high:
         raise ValueError(f"Normalized lowcut frequency ({low}) must be less than normalized highcut frequency ({high})")
    if filter_type == 'lowpass':
        b, a = butter(order, high, btype=filter_type)
    elif filter_type == 'highpass':
        b, a = butter(order, low, btype=filter_type)
    elif filter_type == 'bandpass':       
        b, a = butter(order, [low, high], btype=filter_type)
    else:
        raise ValueError("Invalid filter_type. Choose 'lowpass', 'highpass', or 'bandpass'.")  
    if data.ndim == 1:
        filtered_data = filtfilt(b, a, data)
    elif data.ndim == 2:
        filtered_data = np.zeros_like(data)
        for i in range(data.shape[1]):
            filtered_data[:, i] = filtfilt(b, a, data[:, i])
    else:
        raise ValueError("Data must be 1D or 2D.")
    return filtered_data
filtered_dfs = {}
print("Applying filters to resampled sensor data (64 Hz):")
if 'wrist_ACC' in resampled_dfs:    
    filtered_dfs['wrist_ACC'] = pd.DataFrame(apply_filter(resampled_dfs['wrist_ACC'].values, None, 10, target_freq, 4, 'lowpass'), columns=resampled_dfs['wrist_ACC'].columns)
    print("- Applied low-pass filter to wrist_ACC")
if 'wrist_BVP' in resampled_dfs: 
    filtered_dfs['wrist_BVP'] = pd.DataFrame(apply_filter(resampled_dfs['wrist_BVP'].values, 0.5, 8, target_freq, 4, 'bandpass'), columns=resampled_dfs['wrist_BVP'].columns)
    print("- Applied band-pass filter to wrist_BVP")
if 'wrist_EDA' in resampled_dfs:   
    filtered_dfs['wrist_EDA'] = pd.DataFrame(apply_filter(resampled_dfs['wrist_EDA'].values, None, 1, target_freq, 4, 'lowpass'), columns=resampled_dfs['wrist_EDA'].columns)
    print("- Applied low-pass filter to wrist_EDA")
if 'wrist_TEMP' in resampled_dfs:  
    filtered_dfs['wrist_TEMP'] = pd.DataFrame(apply_filter(resampled_dfs['wrist_TEMP'].values, None, 0.1, target_freq, 4, 'lowpass'), columns=resampled_dfs['wrist_TEMP'].columns)
    print("- Applied low-pass filter to wrist_TEMP")
if 'chest_ACC' in resampled_dfs:   
    filtered_dfs['chest_ACC'] = pd.DataFrame(apply_filter(resampled_dfs['chest_ACC'].values, None, 10, target_freq, 4, 'lowpass'), columns=resampled_dfs['chest_ACC'].columns)
    print("- Applied low-pass filter to chest_ACC")
if 'chest_ECG' in resampled_dfs:    
    filtered_dfs['chest_ECG'] = pd.DataFrame(apply_filter(resampled_dfs['chest_ECG'].values, 0.5, 30, target_freq, 4, 'bandpass'), columns=resampled_dfs['chest_ECG'].columns)
    print("- Applied band-pass filter to chest_ECG")
if 'chest_EMG' in resampled_dfs:   
    filtered_dfs['chest_EMG'] = pd.DataFrame(apply_filter(resampled_dfs['chest_EMG'].values, 10, 30, target_freq, 4, 'bandpass'), columns=resampled_dfs['chest_EMG'].columns)
    print("- Applied band-pass filter to chest_EMG")
if 'chest_EDA' in resampled_dfs:   
    filtered_dfs['chest_EDA'] = pd.DataFrame(apply_filter(resampled_dfs['chest_EDA'].values, None, 1, target_freq, 4, 'lowpass'), columns=resampled_dfs['chest_EDA'].columns)
    print("- Applied low-pass filter to chest_EDA")
if 'chest_Temp' in resampled_dfs:  
    filtered_dfs['chest_Temp'] = pd.DataFrame(apply_filter(resampled_dfs['chest_Temp'].values, None, 0.1, target_freq, 4, 'lowpass'), columns=resampled_dfs['chest_Temp'].columns)
    print("- Applied low-pass filter to chest_Temp")
if 'chest_Resp' in resampled_dfs:   
    filtered_dfs['chest_Resp'] = pd.DataFrame(apply_filter(resampled_dfs['chest_Resp'].values, None, 0.5, target_freq, 4, 'lowpass'), columns=resampled_dfs['chest_Resp'].columns)
    print("- Applied low-pass filter to chest_Resp")
print("\nExample of filtered wrist BVP data:")
if 'wrist_BVP' in filtered_dfs:
    display(filtered_dfs['wrist_BVP'].head())
print("\nExample of filtered chest ECG data:")
if 'chest_ECG' in filtered_dfs:
    display(filtered_dfs['chest_ECG'].head())


window_size_sec = 60
overlap_sec = 0 
window_size_samples = int(window_size_sec * target_freq)
overlap_samples = int(overlap_sec * target_freq)
step_size_samples = window_size_samples - overlap_samples 
segmented_data = {}
print(f"Segmenting data into {window_size_sec}-second non-overlapping windows ({window_size_samples} samples per window):")
for sensor_name, df in filtered_dfs.items():
    segments = []
    num_samples = len(df)    
    for start_sample in range(0, num_samples - window_size_samples + 1, step_size_samples):
        end_sample = start_sample + window_size_samples
        segment = df.iloc[start_sample:end_sample]
        segments.append(segment)
    segmented_data[sensor_name] = segments
    print(f"- Segmented {sensor_name}: Created {len(segments)} segments of shape {window_size_samples}x{df.shape[1]}")
print("\nExample: Shape of the first segment of wrist_ACC data:")
if 'wrist_ACC' in segmented_data and len(segmented_data['wrist_ACC']) > 0:
    print(segmented_data['wrist_ACC'][0].shape)
else:
    print("No segments created for wrist_ACC.")
print("\nExample: Shape of the first segment of chest_ECG data:")
if 'chest_ECG' in segmented_data and len(segmented_data['chest_ECG']) > 0:
    print(segmented_data['chest_ECG'][0].shape)
else:
    print("No segments created for chest_ECG.")

extracted_features = {}
print("Extracting time-domain features from each segment:")
for sensor_name, segments in segmented_data.items():
    sensor_features = []
    print(f"- Processing {sensor_name} ({len(segments)} segments)")
    for segment in segments:
        features = {}        
        for col in segment.columns:
            features[f'{col}_mean'] = segment[col].mean()
            features[f'{col}_std'] = segment[col].std()
            features[f'{col}_min'] = segment[col].min()
            features[f'{col}_max'] = segment[col].max()
            features[f'{col}_range'] = segment[col].max() - segment[col].min()
            features[f'{col}_median'] = segment[col].median()
            features[f'{col}_variance'] = segment[col].var()
        sensor_features.append(features)
    extracted_features[sensor_name] = pd.DataFrame(sensor_features)
    print(f"  Extracted features for {sensor_name}: shape {extracted_features[sensor_name].shape}")
print("\nExample of extracted features for wrist_ACC:")
if 'wrist_ACC' in extracted_features and not extracted_features['wrist_ACC'].empty:
    display(extracted_features['wrist_ACC'].head())
else:
    print("No features extracted for wrist_ACC.")
print("\nExample of extracted features for chest_ECG:")
if 'chest_ECG' in extracted_features and not extracted_features['chest_ECG'].empty:
     display(extracted_features['chest_ECG'].head())
else:
    print("No features extracted for chest_ECG.")


extracted_features = {}
print("Extracting time-domain features from each segment:")
for sensor_name, segments in segmented_data.items():
    sensor_features = []
    print(f"- Processing {sensor_name} ({len(segments)} segments)")
    for segment in segments:
        features = {}   
        for col in segment.columns:
            features[f'{col}_mean'] = segment[col].mean()
            features[f'{col}_std'] = segment[col].std()
            features[f'{col}_min'] = segment[col].min()
            features[f'{col}_max'] = segment[col].max()
            features[f'{col}_range'] = segment[col].max() - segment[col].min()
            features[f'{col}_median'] = segment[col].median()
            features[f'{col}_variance'] = segment[col].var()
        sensor_features.append(features)
    extracted_features[sensor_name] = pd.DataFrame(sensor_features)
    print(f"  Extracted features for {sensor_name}: shape {extracted_features[sensor_name].shape}")
print("\nExample of extracted features for wrist_ACC:")
if 'wrist_ACC' in extracted_features and not extracted_features['wrist_ACC'].empty:
    display(extracted_features['wrist_ACC'].head())
else:
    print("No features extracted for wrist_ACC.")
print("\nExample of extracted features for chest_ECG:")
if 'chest_ECG' in extracted_features and not extracted_features['chest_ECG'].empty:
     display(extracted_features['chest_ECG'].head())
else:
    print("No features extracted for chest_ECG.")

from scipy.fft import fft
frequency_features = {}
print("\nExtracting frequency-domain features from each segment:")
for sensor_name, segments in segmented_data.items():
    sensor_freq_features = []
    print(f"- Processing {sensor_name} ({len(segments)} segments for frequency features)")   
    for segment in segments:
        freq_features = {}       
        for col in segment.columns:
            signal = segment[col].values
            N = len(signal)           
            yf = fft(signal)            
            xf = np.linspace(0.0, target_freq/2.0, N//2)            
            power_spectrum = 2.0/N * np.abs(yf[0:N//2])**2          
            freq_features[f'{col}_total_power'] = np.sum(power_spectrum)       
            low_freq_band = (xf >= 0.1) & (xf < 1.0)
            freq_features[f'{col}_power_0.1-1Hz'] = np.sum(power_spectrum[low_freq_band])     
            high_freq_band = (xf >= 1.0) & (xf < 10.0)
            freq_features[f'{col}_power_1-10Hz'] = np.sum(power_spectrum[high_freq_band])
        sensor_freq_features.append(freq_features)   
    frequency_features[sensor_name] = pd.DataFrame(sensor_freq_features)
    print(f"  Extracted frequency features for {sensor_name}: shape {frequency_features[sensor_name].shape}")
print("\nExample of extracted frequency features for wrist_BVP:")
if 'wrist_BVP' in frequency_features and not frequency_features['wrist_BVP'].empty:
    display(frequency_features['wrist_BVP'].head())
else:
    print("No frequency features extracted for wrist_BVP.")
print("\nExample of extracted frequency features for chest_ECG:")
if 'chest_ECG' in frequency_features and not frequency_features['chest_ECG'].empty:
    display(frequency_features['chest_ECG'].head())
else:
    print("No frequency features extracted for chest_ECG.")

from scipy.signal import find_peaks
physiological_features = {}
print("\nExtracting physiological features (Heart Rate) from BVP segments:")
if 'wrist_BVP' in segmented_data:
    bvp_segments = segmented_data['wrist_BVP']
    hr_features = []
    print(f"- Processing wrist_BVP ({len(bvp_segments)} segments)")
    for i, segment in enumerate(bvp_segments):
        segment_data = segment['BVP'].values 
        features = {}        
        min_peak_distance = int(target_freq / 3)        
        peaks, _ = find_peaks(segment_data, distance=min_peak_distance)
        if len(peaks) > 1:   
            ibi_samples = np.diff(peaks) 
            ibi_seconds = ibi_samples / target_freq  
            mean_ibi_seconds = np.mean(ibi_seconds)
            features['BVP_mean_HR'] = 60 / mean_ibi_seconds if mean_ibi_seconds > 0 else np.nan 
            if len(ibi_seconds) > 1:
                 ibi_diff = np.diff(ibi_seconds)
                 features['BVP_RMSSD'] = np.sqrt(np.mean(ibi_diff**2))
            else:
                 features['BVP_RMSSD'] = np.nan #
        else:     
            features['BVP_mean_HR'] = np.nan
            features['BVP_RMSSD'] = np.nan
        hr_features.append(features)
    physiological_features['wrist_BVP_HRV'] = pd.DataFrame(hr_features)
    print(f"  Extracted HR/HRV features for wrist_BVP: shape {physiological_features['wrist_BVP_HRV'].shape}")
else:
    print("Wrist BVP segmented data not found.")
print("\nExample of extracted wrist BVP HR/HRV features:")
if 'wrist_BVP_HRV' in physiological_features and not physiological_features['wrist_BVP_HRV'].empty:
    display(physiological_features['wrist_BVP_HRV'].head())
else:
    print("No HR/HRV features extracted for wrist_BVP.")


eda_physiological_features = {}
print("\nExtracting basic physiological features (statistics) from EDA segments:")
if 'wrist_EDA' in segmented_data:
    eda_segments = segmented_data['wrist_EDA']
    wrist_eda_features = []
    print(f"- Processing wrist_EDA ({len(eda_segments)} segments)")
    for segment in eda_segments:
        features = {}        
        if 'EDA' in segment.columns:
            features['wrist_EDA_mean'] = segment['EDA'].mean()
            features['wrist_EDA_median'] = segment['EDA'].median()
            features['wrist_EDA_std'] = segment['EDA'].std()
            features['wrist_EDA_min'] = segment['EDA'].min()
            features['wrist_EDA_max'] = segment['EDA'].max()
            features['wrist_EDA_range'] = segment['EDA'].max() - segment['EDA'].min()
        wrist_eda_features.append(features)
    eda_physiological_features['wrist_EDA'] = pd.DataFrame(wrist_eda_features)
    print(f"  Extracted basic EDA features for wrist_EDA: shape {eda_physiological_features['wrist_EDA'].shape}")
else:
    print("Wrist EDA segmented data not found.")
if 'chest_EDA' in segmented_data:
    eda_segments = segmented_data['chest_EDA']
    chest_eda_features = []
    print(f"- Processing chest_EDA ({len(eda_segments)} segments)")
    for segment in eda_segments:
        features = {}      
        if 'EDA' in segment.columns:
            features['chest_EDA_mean'] = segment['EDA'].mean()
            features['chest_EDA_median'] = segment['EDA'].median()
            features['chest_EDA_std'] = segment['EDA'].std()
            features['chest_EDA_min'] = segment['EDA'].min()
            features['chest_EDA_max'] = segment['EDA'].max()
            features['chest_EDA_range'] = segment['EDA'].max() - segment['EDA'].min()
        chest_eda_features.append(features)
    eda_physiological_features['chest_EDA'] = pd.DataFrame(chest_eda_features)
    print(f"  Extracted basic EDA features for chest_EDA: shape {eda_physiological_features['chest_EDA'].shape}")
else:
    print("Chest EDA segmented data not found.")
print("\nExample of extracted basic EDA features for wrist_EDA:")
if 'wrist_EDA' in eda_physiological_features and not eda_physiological_features['wrist_EDA'].empty:
    display(eda_physiological_features['wrist_EDA'].head())
else:
    print("No basic EDA features extracted for wrist_EDA.")
print("\nExample of extracted basic EDA features for chest_EDA:")
if 'chest_EDA' in eda_physiological_features and not eda_physiological_features['chest_EDA'].empty:
    display(eda_physiological_features['chest_EDA'].head())
else:
    print("No basic EDA features extracted for chest_EDA.")


combined_features = {}
combined_features.update(extracted_features)
for sensor_name, df in frequency_features.items():    
    renamed_cols = {col: f'{sensor_name}_{col}' for col in df.columns}
    combined_features[sensor_name] = combined_features[sensor_name].join(df.rename(columns=renamed_cols))
for sensor_name, df in physiological_features.items():     
    renamed_cols = {col: f'{sensor_name}_{col}' for col in df.columns} 
    if sensor_name in combined_features:
         combined_features[sensor_name] = combined_features[sensor_name].join(df.rename(columns=renamed_cols))
    else:        
         combined_features[sensor_name] = df.rename(columns=renamed_cols)
for sensor_name, df in eda_physiological_features.items():
    combined_features[sensor_name] = combined_features[sensor_name].join(df)
all_sensor_features_list = []
sensor_names_order = sorted(combined_features.keys())
if combined_features:   
    num_segments = len(list(combined_features.values())[0])
    if all(len(df) == num_segments for df in combined_features.values()):
        for sensor_name in sensor_names_order:
             all_sensor_features_list.append(combined_features[sensor_name])
        final_features_df = pd.concat(all_sensor_features_list, axis=1)
        print("\nCombined features from all sensors:")
        display(final_features_df.head())
        print(f"Shape of combined features DataFrame: {final_features_df.shape}")
    else:
        print("Error: Feature DataFrames for different sensors have different numbers of segments. Cannot concatenate.")        
else:
    print("No combined features found.")
    final_features_df = pd.DataFrame() 
if 'subject_data' in locals() and 'label' in subject_data:
    original_labels = subject_data['label']
    original_label_freq = original_freqs['chest_ACC'] 
    target_freq = 64 
    segment_labels = []
    window_size_samples_target_freq = int(window_size_sec * target_freq) 
    window_size_samples_original_freq = int(window_size_sec * original_label_freq) 
    samples_ratio = original_label_freq / target_freq    
    if not final_features_df.empty:
        num_segments = len(final_features_df)
        for i in range(num_segments):          
            start_sample_target = i * window_size_samples_target_freq
            end_sample_target = start_sample_target + window_size_samples_target_freq
            start_sample_original = int(i * window_size_samples_original_freq)
            end_sample_original = int((i + 1) * window_size_samples_original_freq)            
            start_idx = min(start_sample_original, len(original_labels))
            end_idx = min(end_sample_original, len(original_labels))
            if start_idx < end_idx:
                segment_label_window = original_labels[start_idx:end_idx]               
                if len(segment_label_window) > 0:                    
                    values, counts = np.unique(segment_label_window, return_counts=True)
                    mode_label = values[np.argmax(counts)]
                    segment_labels.append(mode_label)
                else:                   
                     segment_labels.append(np.nan) 
            else:              
                 segment_labels.append(np.nan) 
        final_features_df['label'] = segment_labels
        print("\nCombined features with labels:")
        display(final_features_df.head())
        print(f"Shape of final DataFrame with labels: {final_features_df.shape}")
    else:
         print("\nNo features to align with labels.")
else:
    print("Subject data or labels not found. Cannot align features with labels.")

